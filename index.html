<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Omega-Man</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
    :root {
      --bg: #111;
      --fg: #fff;
      --accent: #fff;
      --danger: #f33;
      --panel-bg: #181818;
      --panel-fg: #fff;
      --panel-width: 320px;
      --maze-wall: #fff;
      --maze-bg: #222;
      --dot: #fff;
      --power: #0ff; /* Cyan */
      --omega: #fff;
      --ghost1: #f33; /* Red */
      --ghost2: #3cf; /* Blue */
      --ghost3: #fc3; /* Yellow */
      --ghost4: #9f3; /* Green */
    }
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: 'VT323', monospace;
      font-size: 1.2rem;
      overflow: hidden;
    }
    #game-container {
      display: flex;
      flex-direction: row;
      align-items: flex-start; /* Align canvas and panel to the top */
      gap: 30px;
    }
    canvas {
      background: var(--maze-bg);
      border: 2px solid var(--accent);
      border-radius: 5px;
    }
    #sidePanel {
      width: var(--panel-width);
      padding: 20px;
      background: var(--panel-bg);
      border-radius: 5px;
      border: 2px solid var(--accent);
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    #sidePanel h1 {
      margin: 0 0 10px 0;
      text-align: center;
      font-size: 3rem;
      letter-spacing: 2px;
      color: var(--accent);
    }
    #wallet-section button {
        background: var(--accent);
        color: var(--bg);
        border: none;
        padding: 10px;
        font-family: 'VT323', monospace;
        font-size: 1.2rem;
        width: 100%;
        cursor: pointer;
    }
    #wallet-section button:disabled {
        background: #555;
        cursor: not-allowed;
    }
    #leaderboard {
        border-top: 1px solid var(--accent);
        padding-top: 20px;
    }
    #leaderboard h2 {
        margin-top: 0;
    }
    #leaderboard ol {
        padding-left: 20px;
        margin: 0;
        max-height: 250px;
        overflow-y: auto;
    }
    #leaderboard li {
        margin-bottom: 5px;
    }
    .mobile-controls {
        display: none; /* Hidden by default */
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 150px;
    }
    .mobile-btn {
        position: absolute;
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: 2px solid white;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        font-size: 2rem;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #message-box h2 {
        margin-top: 0;
    }
    #end-game-controls button {
        background: var(--accent);
        color: var(--bg);
        border: none;
        padding: 10px 20px;
        font-family: 'VT323', monospace;
        font-size: 1.2rem;
        cursor: pointer;
        margin: 10px;
        transition: background 0.2s;
    }
    #end-game-controls button:hover:not(:disabled) {
        background: #ccc;
    }
    #end-game-controls button:disabled {
        background: #555;
        color: #999;
        cursor: not-allowed;
    }
    @media (max-width: 900px) {
      body {
        justify-content: flex-start;
        align-items: flex-start;
        padding-top: 20px;
      }
      #game-container {
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }
      .mobile-controls {
        display: block;
      }
    }
    </style>
</head>
<body style="margin:0; background:#111; min-height:100vh; display:flex; align-items:center; justify-content:center;">
    <div id="game-container">
      <canvas id="gameCanvas"></canvas>
      <div id="sidePanel">
        <h1>OMEGA-MAN</h1>
        <div id="score">Score: 0</div>
        <div id="lives">Lives: 3</div>
        <div id="wallet-section">
          <div><b>Wallet:</b> <span id="wallet-status">Not Connected</span></div>
          <button id="connect-wallet">Connect Wallet</button>
        </div>
        <div id="leaderboard">
            <h2>Leaderboard</h2>
            <ol id="leaderboard-list">
                <li>Connect wallet to see scores.</li>
            </ol>
        </div>
      </div>
    </div>
    
    <div class="mobile-controls">
        <button class="mobile-btn" id="btn-up" style="left: 50%; bottom: 80px; transform: translateX(-50%);">▲</button>
        <button class="mobile-btn" id="btn-left" style="left: 25%; bottom: 10px; transform: translateX(-50%);">◀</button>
        <button class="mobile-btn" id="btn-down" style="left: 50%; bottom: 10px; transform: translateX(-50%);">▼</button>
        <button class="mobile-btn" id="btn-right" style="right: 25%; bottom: 10px; transform: translateX(50%);">▶</button>
    </div>

    <div id="message-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; text-align: center; z-index: 1000;">
        <div id="message-box" style="background: #181818; padding: 40px; border-radius: 10px; border: 1px solid var(--accent);">
            <div id="message"></div>
            <div id="end-game-controls" style="display: none; margin-top: 20px;">
                <button id="submit-score-btn">Submit Score</button>
                <button id="new-game-btn">Play Again</button>
            </div>
        </div>
    </div>
    
    <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const TILE_S = 20;
    const MAZE_W = 28;
    const MAZE_H = 36;
    
    const CANVAS_W = TILE_S * MAZE_W;
    const CANVAS_H = TILE_S * MAZE_H;
    canvas.width = CANVAS_W;
    canvas.height = CANVAS_H;

    // 1=wall, 2=dot, 3=power pellet, 0=empty, 4=ghost house door
    const MAZE = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,3,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,3,1],
        [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
        [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
        [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
        [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
        [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
        [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
        [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
        [1,1,1,1,1,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,1,1,1,1],
        [1,1,1,1,1,1,2,1,1,0,1,1,1,4,4,1,1,1,0,1,1,2,1,1,1,1,1,1],
        [1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1],
        [0,0,0,0,0,0,2,0,0,0,1,0,0,0,0,0,0,1,0,0,0,2,0,0,0,0,0,0], // Tunnel
        [1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1],
        [1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],
        [1,1,1,1,1,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,1,1,1,1],
        [1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
        [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
        [1,3,2,2,1,1,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,1,1,2,2,2,3,1],
        [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
        [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
        [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
        [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
        [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1], // Connector Row
        [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1], // Connector Row
        [1,2,2,2,1,2,1,2,2,2,2,1,1,2,2,2,2,1,2,1,2,2,2,2,1,2,2,1],
        [1,2,1,2,1,2,1,2,1,1,2,1,1,2,1,1,2,1,2,1,2,1,2,1,1,2,1,1],
        [1,2,1,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,2,1,1,2,2,1],
        [1,3,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,3,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];
    let originalMaze; // To store the initial state for resets

    // --- GAME STATE ---
    let score = 0;
    let lives = 3;
    let dots = 0;
    let totalDots = 0;
    let gameOver = false;
    let gamePaused = false;
    
    let omega = {};
    let ghosts = [];
    let powerPellet = { active: false, timer: 0 };
    
    const DIRS = [ {x:0, y:-1}, {x:1, y:0}, {x:0, y:1}, {x:-1, y:0} ]; // Up, Right, Down, Left

    // --- WEB3 STATE ---
    const contractAddress = "0x6801d29b5939174ad32f347c7120a99e72858ea4";
    const contractABI = [
        {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"player","type":"address"},{"indexed":false,"internalType":"uint256","name":"score","type":"uint256"}],"name":"ScoreSubmitted","type":"event"},
        {"inputs":[{"internalType":"uint256","name":"_score","type":"uint256"}],"name":"submitScore","outputs":[],"stateMutability":"nonpayable","type":"function"},
        {"inputs":[],"name":"getLeaderboard","outputs":[{"components":[{"internalType":"address","name":"player","type":"address"},{"internalType":"uint256","name":"score","type":"uint256"}],"internalType":"struct Leaderboard.ScoreEntry[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"}
    ];
    let provider, signer, leaderboardContract, userAccount;
    
    // --- DRAWING ---
    function draw() {
        ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
        drawMaze();
        drawOmega();
        drawGhosts();
    }

    function drawMaze() {
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--maze-bg').trim();
        ctx.fillRect(0,0,CANVAS_W, CANVAS_H);

        for (let y = 0; y < MAZE_H; y++) {
            for (let x = 0; x < MAZE_W; x++) {
                const tile = MAZE[y][x];
                if (tile === 1) { // Wall
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--maze-wall').trim();
                    ctx.fillRect(x * TILE_S, y * TILE_S, TILE_S, TILE_S);
                } else if (tile === 2) { // Dot
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--dot').trim();
                    ctx.beginPath();
                    ctx.arc(x * TILE_S + TILE_S / 2, y * TILE_S + TILE_S / 2, TILE_S / 6, 0, Math.PI * 2);
                    ctx.fill();
                } else if (tile === 3) { // Power Pellet
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--power').trim();
                    ctx.beginPath();
                    ctx.arc(x * TILE_S + TILE_S / 2, y * TILE_S + TILE_S / 2, TILE_S / 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (tile === 4) { // Ghost door
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--power').trim();
                    ctx.fillRect(x * TILE_S, y * TILE_S + TILE_S / 2 - 2, TILE_S, 4);
                }
            }
        }
    }

    function drawOmega() {
        ctx.save();
        ctx.translate(omega.x * TILE_S + TILE_S / 2, omega.y * TILE_S + TILE_S / 2);
        
        // Rotate mouth to match movement direction
        const angle = (omega.dir - 1) * Math.PI / 2;
        ctx.rotate(angle);

        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--omega').trim();
        ctx.beginPath();
        const mouthAngle = (Date.now() % 400 < 200) ? Math.PI / 4 : Math.PI / 6;
        ctx.arc(0, 0, TILE_S / 2 - 2, mouthAngle, -mouthAngle);
        ctx.lineTo(0, 0);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    function drawGhosts() {
        ghosts.forEach(ghost => {
            const isFrightened = powerPellet.active;
            const isFlashing = isFrightened && powerPellet.timer < 3 && (Date.now() % 400 < 200);

            if (ghost.eatenTimer > 0) { // Draw as eyes only
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(ghost.x * TILE_S + TILE_S * 0.3, ghost.y * TILE_S + TILE_S / 2, TILE_S / 8, 0, Math.PI * 2);
                ctx.arc(ghost.x * TILE_S + TILE_S * 0.7, ghost.y * TILE_S + TILE_S / 2, TILE_S / 8, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = isFrightened 
                    ? (isFlashing ? '#fff' : getComputedStyle(document.documentElement).getPropertyValue('--power').trim())
                    : getComputedStyle(document.documentElement).getPropertyValue(`--ghost${ghost.id}`).trim();
                
                const x = ghost.x * TILE_S;
                const y = ghost.y * TILE_S;
                const r = TILE_S / 2;
                
                ctx.beginPath();
                ctx.arc(x + r, y + r, r, Math.PI, 0);
                ctx.lineTo(x + TILE_S, y + TILE_S);
                ctx.lineTo(x, y + TILE_S);
                ctx.closePath();
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x + TILE_S * 0.3, y + TILE_S * 0.4, TILE_S/5, 0, Math.PI * 2);
                ctx.arc(x + TILE_S * 0.7, y + TILE_S * 0.4, TILE_S/5, 0, Math.PI * 2);
                ctx.fill();

                // Pupils
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(x + TILE_S * 0.3, y + TILE_S * 0.4, TILE_S/10, 0, Math.PI * 2);
                ctx.arc(x + TILE_S * 0.7, y + TILE_S * 0.4, TILE_S/10, 0, Math.PI * 2);
                ctx.fill();
            }
        });
    }

    // --- GAME LOGIC ---
    function update(dt) {
        updateOmega(dt);
        updateGhosts(dt);
        checkCollisions();
        checkWinCondition();
    }

    function canMove(x, y, isGhost = false) {
        if (x < 0 || x >= MAZE_W || y < 0 || y >= MAZE_H) return false;
        const tile = MAZE[y][x];
        if (isGhost) {
            return tile !== 1;
        }
        return tile !== 1 && tile !== 4;
    }

    function updateOmega(dt) {
        omega.moveTimer -= dt;
        if (omega.moveTimer > 0) return;
        omega.moveTimer = 0.15;

        let nx = omega.x + DIRS[omega.nextDir].x;
        let ny = omega.y + DIRS[omega.nextDir].y;
        if (canMove(nx, ny)) {
            omega.dir = omega.nextDir;
        }
        
        nx = omega.x + DIRS[omega.dir].x;
        ny = omega.y + DIRS[omega.dir].y;
        
        // Handle tunnel
        if (ny === 14) {
            if (nx < 0) nx = MAZE_W - 1;
            if (nx >= MAZE_W) nx = 0;
        }

        if (canMove(nx, ny)) {
            omega.x = nx;
            omega.y = ny;
        }
        
        // Check for dot collection
        const currentTile = MAZE[omega.y][omega.x];
        if (currentTile === 2) {
            MAZE[omega.y][omega.x] = 0; // Eat dot
            score += 10;
            dots--;
            updateScoreDisplay();
        } else if (currentTile === 3) {
            MAZE[omega.y][omega.x] = 0; // Eat power pellet
            score += 50;
            dots--;
            powerPellet.active = true;
            powerPellet.timer = 7; // 7 seconds of power
            updateScoreDisplay();
        }
    }
    
    function updateGhosts(dt) {
        if (powerPellet.active) {
            powerPellet.timer -= dt;
            if (powerPellet.timer <= 0) {
                powerPellet.active = false;
            }
        }

        ghosts.forEach(ghost => {
            if (ghost.eatenTimer > 0) {
                ghost.eatenTimer -= dt;
                if (ghost.eatenTimer <= 0) {
                    ghost.x = ghost.startX;
                    ghost.y = ghost.startY;
                }
                return;
            }

            ghost.moveTimer -= dt;
            if (ghost.moveTimer > 0) return;
            ghost.moveTimer = powerPellet.active ? 0.3 : 0.22; // Slower when frightened

            // AI Logic
            let validMoves = [];
            for (let i = 0; i < 4; i++) {
                // Prevent reversing direction
                if (i === (ghost.dir + 2) % 4) continue;
                
                let nx = ghost.x + DIRS[i].x;
                let ny = ghost.y + DIRS[i].y;
                if (canMove(nx, ny, true)) {
                    validMoves.push(i);
                }
            }

            if (validMoves.length > 0) {
                ghost.dir = validMoves[Math.floor(Math.random() * validMoves.length)];
            }
            
            ghost.x += DIRS[ghost.dir].x;
            ghost.y += DIRS[ghost.dir].y;
        });
    }

    function checkCollisions() {
        for (const ghost of ghosts) {
            if (ghost.eatenTimer > 0) continue;

            if (ghost.x === omega.x && ghost.y === omega.y) {
                if (powerPellet.active) {
                    score += 200;
                    updateScoreDisplay();
                    ghost.eatenTimer = 3; // Respawn after 3 seconds
                    // Move ghost back to start immediately to prevent re-collision
                    ghost.x = ghost.startX; 
                    ghost.y = ghost.startY;
                } else {
                    lives--;
                    updateLivesDisplay();
                    if (lives <= 0) {
                        endGame();
                    } else {
                        resetPositions();
                    }
                    return; // Stop processing collisions for this frame
                }
            }
        }
    }

    function checkWinCondition() {
        if (dots === 0 && !gameOver) {
            endGame();
        }
    }

    function resetPositions() {
        omega.x = 13;
        omega.y = 22;
        ghosts.forEach(g => {
            g.x = g.startX;
            g.y = g.startY;
        });
    }

    // --- UI & STATE MANAGEMENT ---
    const messageEl = document.getElementById('message');
    const overlayEl = document.getElementById('message-overlay');
    
    function updateScoreDisplay() {
        document.getElementById('score').textContent = `Score: ${score}`;
    }

    function updateLivesDisplay() {
        document.getElementById('lives').textContent = `Lives: ${lives}`;
    }

    function resetGame() {
        // First, restore the maze from the original copy
        for(let y = 0; y < MAZE_H; y++) {
            for(let x = 0; x < MAZE_W; x++) {
                MAZE[y][x] = originalMaze[y][x];
            }
        }

        score = 0;
        lives = 3;
        dots = totalDots;
        gameOver = false;
        gamePaused = false;
        powerPellet.active = false;
        
        resetPositions();
        
        updateScoreDisplay();
        updateLivesDisplay();
        overlayEl.style.display = 'none';
    }

    function endGame() {
        gameOver = true;
        gamePaused = true;
        const controlsEl = document.getElementById('end-game-controls');
        const submitBtn = document.getElementById('submit-score-btn');
        const newGameBtn = document.getElementById('new-game-btn');

        const win = dots === 0;
        messageEl.innerHTML = `<h2>${win ? 'You Win!' : 'Game Over'}</h2><p>Final Score: ${score}</p>`;
        
        submitBtn.disabled = !userAccount;
        submitBtn.textContent = 'Submit Score';
        newGameBtn.disabled = false;
        controlsEl.style.display = 'block';

        overlayEl.style.display = 'flex';
    }

    // --- WEB3 ---
    async function initWallet() {
        const connectWalletBtn = document.getElementById('connect-wallet');
        if (window.ethereum) {
            connectWalletBtn.disabled = false;
            connectWalletBtn.addEventListener('click', connectWallet);

            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length > 0) {
                    updateWalletStatus(accounts[0]);
                } else {
                    updateWalletStatus(null);
                }
            });

        } else {
            document.getElementById('wallet-status').textContent = 'No wallet found';
        }
    }
    
    async function connectWallet() {
        try {
            const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
            updateWalletStatus(accounts[0]);
        } catch (err) {
            console.error(err.message);
            document.getElementById('wallet-status').textContent = 'Connection failed';
        }
    }

    function updateWalletStatus(account) {
        const walletStatusEl = document.getElementById('wallet-status');
        const connectWalletBtn = document.getElementById('connect-wallet');
        
        if (account) {
            userAccount = account;
            provider = new ethers.providers.Web3Provider(window.ethereum);
            signer = provider.getSigner();
            leaderboardContract = new ethers.Contract(contractAddress, contractABI, provider);
            
            const truncated = `${account.substring(0, 6)}...${account.substring(account.length - 4)}`;
            walletStatusEl.textContent = truncated;
            connectWalletBtn.textContent = 'Connected';
            connectWalletBtn.disabled = true;
            updateLeaderboard();
        } else {
            userAccount = null;
            walletStatusEl.textContent = 'Not Connected';
            connectWalletBtn.textContent = 'Connect Wallet';
            connectWalletBtn.disabled = false;
        }
    }

    async function updateLeaderboard() {
        const leaderboardListEl = document.getElementById('leaderboard-list');
        if (!leaderboardContract) {
            leaderboardListEl.innerHTML = '<li>Connect wallet to see scores.</li>';
            return;
        }
        leaderboardListEl.innerHTML = '<li>Loading...</li>';
        try {
            const scores = await leaderboardContract.getLeaderboard();
            if (scores.length === 0) {
                leaderboardListEl.innerHTML = '<li>No scores yet. Be the first!</li>';
                return;
            }
            const sortedScores = [...scores].sort((a, b) => b.score - a.score);
            leaderboardListEl.innerHTML = sortedScores.map(entry => 
                `<li>${entry.player.substring(0, 6)}...${entry.player.substring(entry.player.length - 4)}: ${entry.score}</li>`
            ).join('');
        } catch (error) {
            console.error("Leaderboard fetch failed:", error);
            leaderboardListEl.innerHTML = '<li>Error loading scores.</li>';
        }
    }
    
    async function submitScore(finalScore) {
        if (!leaderboardContract || !signer) {
            alert("Please connect your wallet to submit your score.");
            return;
        }
        const submitBtn = document.getElementById('submit-score-btn');
        const newGameBtn = document.getElementById('new-game-btn');
        submitBtn.disabled = true;
        newGameBtn.disabled = true;
        submitBtn.textContent = 'Submitting...';

        const contractWithSigner = leaderboardContract.connect(signer);
        try {
            const tx = await contractWithSigner.submitScore(finalScore);
            submitBtn.textContent = 'Confirming...';
            await tx.wait();
            submitBtn.textContent = 'Score Submitted!';
            newGameBtn.disabled = false; 
            await updateLeaderboard();
        } catch (error) {
            console.error("Score submission failed:", error);
            alert("Score submission failed. See console for details.");
            submitBtn.textContent = 'Submission Failed';
            setTimeout(() => {
                if (gameOver) {
                    submitBtn.disabled = !userAccount;
                    newGameBtn.disabled = false;
                    submitBtn.textContent = 'Submit Score';
                }
            }, 2000);
        }
    }

    // --- CONTROLS ---
    window.addEventListener('keydown', e => {
        if (['ArrowUp', 'ArrowRight', 'ArrowDown', 'ArrowLeft'].includes(e.key)) {
            e.preventDefault();
            const keyMap = { 'ArrowUp': 0, 'ArrowRight': 1, 'ArrowDown': 2, 'ArrowLeft': 3 };
            omega.nextDir = keyMap[e.key];
        }
    });

    function handleMobile(dir) {
        omega.nextDir = dir;
    }

    document.getElementById('btn-up').addEventListener('touchstart', (e) => { e.preventDefault(); handleMobile(0); });
    document.getElementById('btn-left').addEventListener('touchstart', (e) => { e.preventDefault(); handleMobile(3); });
    document.getElementById('btn-down').addEventListener('touchstart', (e) => { e.preventDefault(); handleMobile(2); });
    document.getElementById('btn-right').addEventListener('touchstart', (e) => { e.preventDefault(); handleMobile(1); });

    // --- GAME INIT & LOOP ---
    let lastTime = 0;
    
    function gameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        if (!gamePaused) {
            update(dt);
        }
        
        draw();
        requestAnimationFrame(gameLoop);
    }
    
    function init() {
        // Deep copy of the initial maze state for resetting the game
        originalMaze = JSON.parse(JSON.stringify(MAZE));
        MAZE.forEach(row => {
            row.forEach(tile => {
                if (tile === 2 || tile === 3) {
                    totalDots++;
                }
            });
        });
        dots = totalDots;

        omega = { x: 13, y: 22, dir: 0, nextDir: 0, moveTimer: 0 };
        ghosts = [
            { id: 1, x: 13, y: 14, startX: 13, startY: 14, dir: 2, eatenTimer: 0, moveTimer: 0 },
            { id: 2, x: 14, y: 14, startX: 14, startY: 14, dir: 2, eatenTimer: 0, moveTimer: 0.1 },
            { id: 3, x: 12, y: 14, startX: 12, startY: 14, dir: 2, eatenTimer: 0, moveTimer: 0.2 },
            { id: 4, x: 15, y: 14, startX: 15, startY: 14, dir: 2, eatenTimer: 0, moveTimer: 0.3 }
        ];

        initWallet();
        resetGame();
        requestAnimationFrame(gameLoop);
    }

    document.getElementById('new-game-btn').addEventListener('click', () => {
        resetGame();
    });

    document.getElementById('submit-score-btn').addEventListener('click', () => {
        submitScore(score);
    });

    init();

    </script>
</body>
</html>
